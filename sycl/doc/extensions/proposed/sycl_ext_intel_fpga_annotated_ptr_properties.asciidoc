= sycl_ext_intel_fpga_annotated_ptr_properties

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++
:dpcpp: DPC++

== Notice

Copyright (c) 2021 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

Abhishek Tiwari, Intel +
Joseph Garvey, Intel


== Dependencies

This extension is written against the SYCL 2020 specification, revision 4.

It depends on the following extensions:

 - link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]
 - link:sycl_ext_oneapi_annotated_ptr.asciidoc[sycl_ext_oneapi_annotated_ptr]

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Overview

This extension introduces properties for the class
`sycl::ext::oneapi::annotated_ptr`. The properties will influence the kernel
argument interfaces for FPGA kernels and can be ignored for other devices.

Some examples of the syntax are shown below.

.Example 1
[source,c++]
----
annotated_ptr<MyType, properties<
  mem_id<1>, kernel_arg_awidth<32>, kernel_arg_dwidth<>64>> ptr_a;
----

.Example 2
[source,c++]
----
auto ptr_p = malloc_shared<int>(1, q, properties{mem_id<2>});
auto ptr_q = annotated_ptr(ptr_a, properties{
  kernel_arg_awidth<32>, kernel_arg_dwidth<64>});
----

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_FPGA_ANNOTATED_PTR_PROPERTIES` to one of the values
defined in the table below.  Applications can test for the existence of this
macro to determine if the implementation supports this feature, or applications
can test the macro's value to determine which of the extension's features the
implementation supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

=== Kernel Argument Interface Properties

Below is a list of compile-time constant properties supported with
`annotated_ptr`. These properties control the kernel argument interface on FPGA
devices.

```c++
namespace sycl::ext::oneapi::experimental {
struct kernel_arg_mm_host_key {
  using value_t = property_value<kernel_arg_mm_host_key>;
};

struct kernel_arg_agent_register_key {
  using value_t = property_value<kernel_arg_agent_register_key>;
};

struct kernel_arg_stable_key {
  using value_t = property_value<kernel_arg_stable_key>;
};

struct mem_id_key {
  template<int K>
  using value_t = property_value<mem_id_key, std::integral_constant<int, K>>;
};

struct kernel_arg_awidth_key {
  template<int K>
  using value_t = property_value<
    kernel_arg_awidth_key, std::integral_constant<int, K>>;
};

struct kernel_arg_dwidth_key {
  template<int K>
  using value_t = property_value<
    kernel_arg_dwidth_key, std::integral_constant<int, K>>;
};

enum class kernel_arg_read_write_mode_enum {
  read_write,
  read,
  write
};

struct kernel_arg_read_write_mode_key {
  template<kernel_arg_read_write_mode_enum mode>
  using value_t = property_value<kernel_arg_read_write_mode_key,
    std::integral_constant<kernel_arg_read_write_mode_enum, mode>>;
};

struct kernel_arg_latency_key {
  template<int K>
  using value_t = property_value<kernel_arg_latency_key,
    std::integral_constant<int, K>>;
};

struct kernel_arg_maxburst_key {
  template<int K>
  using value_t = property_value<
    kernel_arg_maxburst_key, std::integral_constant<int, K>>;
};

struct kernel_arg_wait_request_key {
  template<bool K>
  using value_t = property_value<kernel_arg_wait_request_key,
    std::integral_constant<bool, K>>;
};

inline constexpr kernel_arg_mm_host_key::value_t kernel_arg_mm_host;
inline constexpr kernel_arg_agent_register_key::value_t
 kernel_arg_agent_register;
inline constexpr kernel_arg_stable_key::value_t kernel_arg_stable;
template<int K> inline constexpr mem_id_key::value_t<K> mem_id;
template<int K> inline constexpr kernel_arg_awidth_key::value_t<K>
 kernel_arg_awidth;
template<int K> inline constexpr kernel_arg_dwidth_key::value_t<K>
 kernel_arg_dwidth;
template<kernel_arg_read_write_mode_enum mode>
inline constexpr kernel_arg_read_write_mode_key::value_t<mode>
 kernel_arg_read_write_mode;
inline constexpr kernel_arg_read_write_mode_key::value_t<
  kernel_arg_read_write_mode_enum::read>  kernel_arg_read_write_mode_read;
inline constexpr kernel_arg_read_write_mode_key::value_t<
  kernel_arg_read_write_mode_enum::write>  kernel_arg_read_write_mode_write;
inline constexpr kernel_arg_read_write_mode_key::value_t<
  kernel_arg_read_write_mode_enum::read_write>
    kernel_arg_read_write_mode_readwrite;
template<int K> inline constexpr kernel_arg_latency_key::value_t<K>
  kernel_arg_latency;
template<int K> inline constexpr kernel_arg_maxburst_key::value_t<K>
 kernel_arg_maxburst;
template<int K> inline constexpr kernel_arg_wait_request_key::value_t<K>
 kernel_arg_wait_request;
inline constexpr kernel_arg_wait_request_key::value_t<true>
 kernel_arg_wait_request_requested;
inline constexpr kernel_arg_wait_request_key::value_t<false>
 kernel_arg_wait_request_not_requested;

template<> struct is_property_key<kernel_arg_mm_host_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_agent_register_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_stable_key> : std::true_type {};
template<> struct is_property_key<mem_id_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_awidth_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_dwidth_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_read_write_mode_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_latency_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_maxburst_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_wait_request_key> : std::true_type {};

template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_mm_host_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_agent_register_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_stable_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<mem_id_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_awidth_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_dwidth_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_read_write_mode_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_latency_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_maxburst_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_wait_request_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
} // namespace experimental::oneapi::ext::sycl
```
--

NOTE: All of the properties defined in this extension except `mem_id` are
meaningful only the kernel argument and are not meaningful within the device
code.

Hence, all the properties except `mem_id` allow implicit conversion of
`annotated_ptr<T, PropertyListT>` to `T`, effectively losing the annotation
within the device and only retaining them on the kernel argument.

[frame="topbot",options="header"]
|===
|Property |Description

a|
[source,c++]
----
kernel_arg_mm_host
----
a|
Directs the compiler to generate a pointer argument interface with a dedicated
input port on the kernel to input the pointer address into the kernel.

The interface can be further customized with the other properties listed in this
extension. However, specifying this property applies the following properties
with their default values:

- mem_id
- kernel_arg_awidth
- kernel_arg_dwidth
- kernel_arg_read_write_mode
- kernel_arg_wait_request
- kernel_arg_maxburst
- kernel_arg_latency

If any of these need to have a value different from the default, they must be
specified as separate property on the type.

a|
[source,c++]
----
kernel_arg_agent_register
----
a|
Directs the compiler to create a register to store the base address of the
of the pointer interface as opposed to creating a dedicated input port on the
kernel for supplying the pointer base address.

a|
[source,c++]
----
kernel_arg_stable
----
a|
Specifies that the input pointer address to the kernel will not change during
the execution of the kernel. The input can still change after all active
kernel invocations have finished.

If the input is changed while the kernel is executing, the behavior is
undefined.

a|
[source,c++]
----
mem_id<id>
----
a|
Specifies a global memory identifier for the pointer interface. A default
value is set by the implementation.

a|
[source,c++]
----
kernel_arg_awidth<width>
----
a|
This property can only be used if the property `kernel_arg_mm_host` has been
specified.

Specifies the width of the memory-mapped address bus in bits. The default is
set to 64. Valid values: Integer value in the range 1 – 64.

a|
[source,c++]
----
kernel_arg_dwidth<width>
----
a|
This property can only be used if the property `kernel_arg_mm_host` has been
specified.

Specifies the width of the memory-mapped data bus in bits. The default is set
to 64. Valid values: 8, 16, 32, 64, 128, 256, 512, or 1024.

a|
[source,c++]
----
kernel_arg_read_write_mode<mode>
----
a|
This property can only be used if the property `kernel_arg_mm_host` has been
specified.

Specifies the port direction of the interface. `mode` can be one of:

`read_write` - Interface can be used for read and write operations.

`read` - Interface can only be used for read operations.

`write` - Interface can only be used for write operations.

The default is set to `read_write`.

For convenience, the following are provided:

 - kernel_arg_read_write_mode_read
 - kernel_arg_read_write_mode_write
 - kernel_arg_read_write_mode_readwrite

a|
[source,c++]
----
kernel_arg_latency<value>
----
a|
This property can only be used if the property `kernel_arg_mm_host` has been
specified.

Specifies the guaranteed latency in cycles, from when a read command exits
the kernel to when the external memory returns valid read data. The default
is set to 1.

A value of 0 specifies a variable latency and a positive value specifies a
fixed latency.

a|
[source,c++]
----
kernel_arg_maxburst<value>
----
a|
This property can only be used if the property `kernel_arg_mm_host` has been
specified.

Specifies the maximum number of data transfers that can be associated with a
read or write transaction. The default is set to 1.

Legal values: Integer value in the range 1 – 1024.

a|
[source,c++]
----
kernel_arg_wait_request<flag>
----
a|
This property can only be used if the property `kernel_arg_mm_host` has been
specified.

Specifies whether the 'wait request' signal is generated or not. This signal is
asserted by the memory system when it is unable to respond to a read or write
request. The default is set to `false`.

For convenience, the following are provided:

 - kernel_arg_wait_request_requested
 - kernel_arg_wait_request_not_requested
|===
--

=== Aliases provided for convenience

[source,c++]
----
namespace sycl::ext::oneapi::experimental{
  template <typename T, typename PropertyListT>
  using mm_host = annotated_ptr<T, properties{
    kernel_arg_mm_host, PropertyListT}>;

  template <typename T, typename PropertyListT>
  using agent_register = annotated_ptr<T, properties{
    kernel_arg_agent_register, PropertyListT}>;
}; // namespace sycl::ext::oneapi::experimental
----

=== Usage Examples

The example below shows a simple kernel with one customized pointer argument
interface `a` and a scalar kernel argument `n`. The interface has default values
for the customizable settings as the alias `mm_host` specifies the property
`kernel_arg_mm_host`.

.Usage Example 1
```c++
using sycl::ext::oneapi::experimental;
struct MyKernel {
  mm_host<int> a;
  int n;
  MyKernel(mm_host<int> a_, int n_) : a(a_), n(n_) {}
  void operator()() const {
    for (int i=0; i<n; i++) {
      a[i] *= 2;
    }
  }
};

int main () {
  sycl::queue q;
  constexpr int kN = 10;
  // Constructs an object of type annotated_ptr<int>
  auto array_a = malloc_shared<int>(kN, q);
  // ...
  // MyKernel member 'a' has type mm_host<int>, which can be constructed from an
  // annotated_ptr<int> or even an integer USM pointer since an
  // annotated_ptr<T, PropertyListA> can be constructed from T* or from an
  // annotated_ptr<T, PropertyListB> as long as 'PropertyListB' is a valid
  // subset of 'PropertyListA'
  q.single_task(MyKernel{array_a, kN}).wait();

  // ...
  sycl::free(array_a, q);
}
```

In the example below, the kernel arguments are two customized pointer interfaces
and a scalar argument.  The two pointers point to separate memories as specified
by the property `mem_id`.

.Usage Example 2
```c++
using sycl::ext::oneapi::experimental;
struct MyKernel {
  using MyMMHostA = mm_host<int, properties<mem_id<1>, kernel_arg_awidth<32>,
   kernel_arg_dwidth<32>>>;
  using MyMMHostB = mm_host<int, properties<mem_id<2>, kernel_arg_awidth<128>,
   kernel_arg_dwidth<128>>>;
  // struct members become kernel arguments
  MyMMHostA a;
  MyMMHostB b;
  int n;
  MyKernel(MyMMHostA a_, MyMMHostB b_, int n_) : a(a_), b(b_), n(n_) {}
  void operator()() const {
    for (int i=0; i<n; i++) {
      a[i] *= 2;
      b[i] += 2;
    }
  }
};

int main () {
  sycl::queue q;
  constexpr int kN = 10;
  // Constructs an object of type annotated_ptr<int, properties<mem_id<1>>>
  auto array_a = malloc_shared<int>(
    kN, q, MyKernel::MyMMHostA::get_property<mem_id_key>());
  // Constructs an object of type annotated_ptr<int, properties<mem_id<2>>>
  auto array_b = malloc_shared<int>(
    kN, q, MyKernel::MyMMHostB::get_property<mem_id_key>());
  // ...

  // 'array_a', 'array_b' and MyKernel members 'a', and 'b' are all
  // annotated_ptr objects which wrap pointers to integers
  // 'a' can be constructed from 'array_a' because the properties on the type of
  // the object 'a' are a legal super set of the properties on the type of
  // object 'array_a'. Same applies for 'b' and 'array_b'
  q.single_task(MyKernel{array_a, array_b, kN}).wait();

  // ...
  sycl::free(array_a, q);
  sycl::free(array_b, q);
}
```

In the example below, the kernel arguments are two pointer interfaces where the
pointers' base addresses are stored in agent registers. The two pointers point
to separate memories as specified by the property `mem_id`.

.Usage Example 3
```c++
using sycl::ext::oneapi::experimental;
struct MyKernel {
  using MyMMHostA = mm_host<
    int, properties<kernel_arg_agent_register, mem_id<1>>>;
  using MyMMHostB = mm_host<
    int, properties<kernel_arg_agent_register, mem_id<2>>>;
  MyMMHostA a;
  MyMMHostB b;
  MyKernel(MyMMHostA a_, MyMMHostB b_) : a(a_), b(b_) {}
  void operator()() const {
    *a = (*a) + 2;
    *b = (*b) * 2;
  }
};

int main () {
  sycl::queue q;
  auto ptr1 = malloc_shared<int>(1, q,
   MyKernel::MyMMHostA::get_property<mem_id_key>());
  auto ptr2 = malloc_shared<int>(1, q,
   MyKernel::MyMMHostB::get_property<mem_id_key>());
  *ptr1 = 5;
  *ptr2 = 10;
  // Again, struct members can be constructed from ptr1 and ptr2 since the
  // type of the struct members are annotated_ptrs with a valid superset of the
  // properties of ptr1 and ptr2 and all of the types involved are wrappers over
  // integer pointers
  q.single_task(MyKernel{ptr1, ptr2}).wait();

  // ...
  sycl::free(ptr1, q);
  sycl::free(ptr2, q);
}
```

== Issues

1. Should property defaults and ranges be specified in the spec document or
 should we just say that the defaults and ranges are defined by the
 implementation?

2. I am not sure if the property `kernel_arg_mm_host` is needed since
all annotated_ptrs will result in a pointer interface for the FPGA. Should I
remove it? If yes, should we change the `mm_host` alias to
`using mm_host = annotated_ptr<T, properties{PropertyListT}>` instead? Or remove
that from the extension all together?

3. `kernel_arg` prefix is too long. Is a `mem_` prefix acceptable? Or maybe
just an `arg_` prefix? Is that coupled with the description/doc enough to
emphasize that these only make sense on the kernel arguments?

4. Should we add a new property argument to `kernel_arg_latency` to separate
specifying fixed latency and variable latency.
Yes, this is a TODO.

5. Examples here also depend on USM `malloc*` API returning `annotated_ptr`.
Should I link to that extension (create one if one doesn't exist), or not show
the `malloc` calls in the examples? I think I should do the latter to keep these
extensions separate. An implementation could support these properties and
not the `malloc` changes and still have value.

6. Does the `annotated_ptr` spec need more clarification for the ctor:
`template <typename T, typename P> explicit annotated_ptr(
  annotated_ptr<T, P> const & ConvertFrom)` ? What is a valid superset? How to
convey that constructing an
`annotated_ptr<T, properties<kernel_arg_awidth<32>>>` with
`annotated_ptr<T, properties<kernel_arg_awidth<N>>>` is illegal if `N` is not
32?

7. Should the presence of `mem_id` cause deletion of the implicit conversion
operator `annotated_ptr<T, propertyListT>::operator T*()`? I am unsure. 

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2022-04-13|Abhishek Tiwari|*Initial draft*
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
