= sycl_ext_intel_fpga_annotated_ptr_properties

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++
:dpcpp: DPC++

== Notice

Copyright (c) 2021 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

Abhishek Tiwari, Intel +
Joseph Garvey, Intel


== Dependencies

This extension is written against the SYCL 2020 specification, revision 4.

It depends on the following extensions:

 - link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]
 - link:sycl_ext_oneapi_annotated_ptr.asciidoc[sycl_ext_oneapi_annotated_ptr]

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Overview

This extension introduces properties for the class
`sycl::ext::oneapi::annotated_ptr`. The properties will influence the kernel
argument interfaces for FPGA kernels and can be ignored for other devices.

Some examples of the syntax are shown below.

.Example 1
[source,c++]
----
annotated_ptr<MyType, properties<
  buffer_location<1>, kernel_arg_awidth<32>, kernel_arg_dwidth<>64>> ptr_a;
----

.Example 2
[source,c++]
----
auto ptr_p = malloc_shared<int>(1, q, properties{buffer_location<2>});
auto ptr_q = annotated_ptr(ptr_a, properties{
  kernel_arg_awidth<32>, kernel_arg_dwidth<64>});
----

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_FPGA_ANNOTATED_PTR_PROPERTIES` to one of the values
defined in the table below.  Applications can test for the existence of this
macro to determine if the implementation supports this feature, or applications
can test the macro's value to determine which of the extension's features the
implementation supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

=== `annotated_ptr` Properties

Below is a list of compile-time constant properties supported with
`annotated_ptr`. These properties control the kernel argument interface on FPGA
devices.

```c++
struct kernel_arg_conduit_key {
  using value_t = property_value<kernel_arg_conduit_key>;
};

struct kernel_arg_register_map_key {
  using value_t = property_value<kernel_arg_register_map_key>;
};

struct kernel_arg_stable_key {
  using value_t = property_value<kernel_arg_stable_key>;
};

struct buffer_location_key {
  template<int K>
  using value_t = property_value<
    buffer_location_key, std::integral_constant<int, K>>;
};

struct kernel_arg_awidth_key {
  template<int K>
  using value_t = property_value<
    kernel_arg_awidth_key, std::integral_constant<int, K>>;
};

struct kernel_arg_dwidth_key {
  template<int K>
  using value_t = property_value<
    kernel_arg_dwidth_key, std::integral_constant<int, K>>;
};

enum class kernel_arg_read_write_mode_enum {
  read_write,
  read,
  write
};

struct kernel_arg_read_write_mode_key {
  template<kernel_arg_read_write_mode_enum mode>
  using value_t = property_value<kernel_arg_read_write_mode_key,
    std::integral_constant<kernel_arg_read_write_mode_enum, mode>>;
};

struct kernel_arg_latency_key {
  template<int K>
  using value_t = property_value<kernel_arg_latency_key,
    std::integral_constant<int, K>>;
};

struct kernel_arg_maxburst_key {
  template<int K>
  using value_t = property_value<
    kernel_arg_maxburst_key, std::integral_constant<int, K>>;
};

struct kernel_arg_wait_request_key {
  template<bool K>
  using value_t = property_value<kernel_arg_wait_request_key,
    std::integral_constant<bool, K>>;
};

inline constexpr kernel_arg_conduit_key::value_t
 kernel_arg_conduit;
inline constexpr kernel_arg_register_map_key::value_t
 kernel_arg_register_map;
inline constexpr kernel_arg_stable_key::value_t kernel_arg_stable;
template<int K> inline constexpr buffer_location_key::value_t<K>
 buffer_location;
template<int K> inline constexpr kernel_arg_awidth_key::value_t<K>
 kernel_arg_awidth;
template<int K> inline constexpr kernel_arg_dwidth_key::value_t<K>
 kernel_arg_dwidth;
template<kernel_arg_read_write_mode_enum mode>
inline constexpr kernel_arg_read_write_mode_key::value_t<mode>
 kernel_arg_read_write_mode;
inline constexpr kernel_arg_read_write_mode_key::value_t<
  kernel_arg_read_write_mode_enum::read>  kernel_arg_read_write_mode_read;
inline constexpr kernel_arg_read_write_mode_key::value_t<
  kernel_arg_read_write_mode_enum::write>  kernel_arg_read_write_mode_write;
inline constexpr kernel_arg_read_write_mode_key::value_t<
  kernel_arg_read_write_mode_enum::read_write>
    kernel_arg_read_write_mode_readwrite;
template<int K> inline constexpr kernel_arg_latency_key::value_t<K>
  kernel_arg_latency;
template<int K> inline constexpr kernel_arg_maxburst_key::value_t<K>
 kernel_arg_maxburst;
template<int K> inline constexpr kernel_arg_wait_request_key::value_t<K>
 kernel_arg_wait_request;
inline constexpr kernel_arg_wait_request_key::value_t<true>
 kernel_arg_wait_request_requested;
inline constexpr kernel_arg_wait_request_key::value_t<false>
 kernel_arg_wait_request_not_requested;

template<> struct is_property_key<kernel_arg_conduit_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_register_map_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_stable_key> : std::true_type {};
template<> struct is_property_key<buffer_location_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_awidth_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_dwidth_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_read_write_mode_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_latency_key> : std::true_type {};
template<> struct is_property_key<kernel_arg_maxburst_key> : std::true_type {};
template<> struct is_property_key<
  kernel_arg_wait_request_key> : std::true_type {};

template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_conduit_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_register_map_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_stable_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<buffer_location_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_awidth_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_dwidth_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_read_write_mode_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_latency_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_maxburst_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<kernel_arg_wait_request_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
} // namespace experimental::oneapi::ext::sycl
```
--

NOTE: All of the properties defined in this extension are meaningful only on the
kernel argument and are not meaningful within the device code.

All the properties defined in this specification allow implicit conversion of
`annotated_ptr<T, PropertyListT>` to `T`, effectively losing the annotation
within the device code when this conversion operator is used. The properties
are only preserved on the kernel argument.

[frame="topbot",options="header"]
|===
|Property |Description

a|
[source,c++]
----
kernel_arg_conduit
----
a|
Directs the compiler to create a dedicated input port on the kernel for the
input data.

a|
[source,c++]
----
kernel_arg_register_map
----
a|
Directs the compiler to create a register to store the base address of the
of the pointer interface as opposed to creating a dedicated input port on the
kernel for supplying the pointer base address.

a|
[source,c++]
----
kernel_arg_stable
----
a|
Specifies that the input pointer address to the kernel will not change during
the execution of the kernel. The input can still change after all active
kernel invocations have finished.

If the input is changed while the kernel is executing, the behavior is
undefined.

a|
[source,c++]
----
buffer_location<id>
----
a|
Specifies a global memory identifier for the pointer interface.

a|
[source,c++]
----
kernel_arg_awidth<width>
----
a|
Specifies the width of the memory-mapped address bus in bits. The default is
set to 64.

a|
[source,c++]
----
kernel_arg_dwidth<width>
----
a|
Specifies the width of the memory-mapped data bus in bits. The default is set
to 64.

a|
[source,c++]
----
kernel_arg_read_write_mode<mode>
----
a|
Specifies the port direction of the interface. `mode` can be one of:

`read_write` - Interface can be used for read and write operations.

`read` - Interface can only be used for read operations.

`write` - Interface can only be used for write operations.

The default is set to `read_write`.

For convenience, the following are provided:

 - kernel_arg_read_write_mode_read
 - kernel_arg_read_write_mode_write
 - kernel_arg_read_write_mode_readwrite

a|
[source,c++]
----
kernel_arg_latency<value>
----
a|
Specifies the guaranteed latency in cycles, from when a read command exits
the kernel to when the external memory returns valid read data. The default
is set to 1.

A value of 0 specifies a variable latency and a positive value specifies a
fixed latency.

a|
[source,c++]
----
kernel_arg_maxburst<value>
----
a|
Specifies the maximum number of data transfers that can be associated with a
read or write transaction. The default is set to 1.

a|
[source,c++]
----
kernel_arg_wait_request<flag>
----
a|
Specifies whether the 'wait request' signal is generated or not. This signal is
asserted by the memory system when it is unable to respond to a read or write
request. The default is set to `false`.

For convenience, the following are provided:

 - kernel_arg_wait_request_requested
 - kernel_arg_wait_request_not_requested
|===
--

=== Usage Examples

The example below shows a simple kernel with one customized pointer argument
interface `a` and a scalar kernel argument `n`. The pointer properties such
as `kernel_arg_awidth`, `kernel_arg_awidth`, etc will take the default values.

.Usage Example 1
```c++
using sycl::ext::oneapi::experimental;
struct MyKernel {
  annotated_ptr<int> a;
  int n;
  MyKernel(annotated_ptr<int> a_, int n_) : a(a_), n(n_) {}
  void operator()() const {
    for (int i=0; i<n; i++) {
      a[i] *= 2;
    }
  }
};

int main () {
  sycl::queue q;
  constexpr int kN = 10;
  // Constructs an object of type annotated_ptr<int>
  auto array_a = malloc_shared<int>(kN, q);
  // ...
  q.single_task(MyKernel{array_a, kN}).wait();

  // ...
  sycl::free(array_a, q);
}
```

In the example below, the kernel arguments are two customized pointer interfaces
and a scalar argument.  The two pointers point to separate memories as specified
by the property `buffer_location`.

.Usage Example 2
```c++
using sycl::ext::oneapi::experimental;
struct MyKernel {
  using MyPtrA = annotated_ptr<int, properties<
    buffer_location<1>, kernel_arg_awidth<32>, kernel_arg_dwidth<32>>>;
  using MyPtrB = annotated_ptr<int, properties<
    buffer_location<2>, kernel_arg_awidth<128>, kernel_arg_dwidth<128>>>;
  // struct members become kernel arguments
  MyPtrA a;
  MyPtrB b;
  int n;
  MyKernel(MyPtrA a_, MyPtrB b_, int n_) : a(a_), b(b_), n(n_) {}
  void operator()() const {
    for (int i=0; i<n; i++) {
      a[i] *= 2;
      b[i] += 2;
    }
  }
};

int main () {
  sycl::queue q;
  constexpr int kN = 10;
  // Constructs an object of type annotated_ptr<int, properties<buffer_location<1>>>
  auto array_a = malloc_shared<int>(
    kN, q, MyKernel::MyPtrA::get_property<buffer_location_key>());
  // Constructs an object of type annotated_ptr<int, properties<buffer_location<2>>>
  auto array_b = malloc_shared<int>(
    kN, q, MyKernel::MyPtrB::get_property<buffer_location_key>());
  // ...

  // 'array_a', 'array_b' and MyKernel members 'a', and 'b' are all
  // annotated_ptr objects which wrap pointers to integers
  // 'a' can be constructed from 'array_a' because the properties on the type of
  // the object 'a' are a legal super set of the properties on the type of
  // object 'array_a'. Same applies for 'b' and 'array_b'
  q.single_task(MyKernel{array_a, array_b, kN}).wait();

  // ...
  sycl::free(array_a, q);
  sycl::free(array_b, q);
}
```

== Issues

1. `kernel_arg` prefix is too long. Is a `mem_` prefix acceptable? Or maybe
just an `arg_` prefix? Is that coupled with the description/doc enough to
emphasize that these properties only influence kernel arguments?

2. Should we add a new property argument to `kernel_arg_latency` to separate
specifying fixed latency and variable latency.
Yes, in a future extension we can introduce a separate property.

3. [RESOLVED] Examples here also depend on USM `malloc*` API returning
`annotated_ptr`.
Should I link to that extension (create one if one doesn't exist), or not show
the `malloc` calls in the examples? I think I should do the latter to keep these
extensions separate. An implementation could support these properties and
not the `malloc` changes and still have value.
And. Can remove malloc calls from the examples here for keeping the spec
simple and to keep it focussed on `annotated_ptr`.

4. TODO: Link the fpga_kernel_properties spec to this one. Specifying certain
fpga kernel properties should result in changes to kernel arguments.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2022-04-13|Abhishek Tiwari|*Initial draft*
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
