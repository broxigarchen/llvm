= sycl_ext_intel_fpga_annotated_ptr_properties

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++
:dpcpp: DPC++

== Notice

Copyright (c) 2021 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

Abhishek Tiwari, Intel +
Joseph Garvey, Intel


== Dependencies

This extension is written against the SYCL 2020 specification, revision 4.

It depends on the following extensions:

 - link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]
 - link:sycl_ext_oneapi_annotated_ptr.asciidoc[sycl_ext_oneapi_annotated_ptr]

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Overview

This extension introduces properties for the class
`sycl::ext::oneapi::annotated_ptr`. The properties will influence the kernel
argument interfaces for FPGA kernels and can be ignored for other devices.

Some examples of the syntax are shown below.

.Example 1
[source,c++]
----
annotated_ptr<MyType,
  properties<buffer_location<1>, awidth<32>, dwidth<64>> arg_a;
----

.Example 2
[source,c++]
----
// Allocate memory
auto ptr = ...
auto arg_a = annotated_ptr(ptr, properties{buffer_location<1>, awidth<32>, dwidth<64>});
----

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_FPGA_ANNOTATED_PTR_PROPERTIES` to one of the values
defined in the table below.  Applications can test for the existence of this
macro to determine if the implementation supports this feature, or applications
can test the macro's value to determine which of the extension's features the
implementation supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

=== `annotated_ptr` Properties

Below is a list of compile-time constant properties supported with
`annotated_ptr`. These properties control the kernel argument interface on FPGA
devices.

All of the properties defined in this extension are meaningful only on the
kernel argument and are not meaningful within the kernel body.

```c++
struct conduit_key {
  using value_t = property_value<conduit_key>;
};

struct register_map_key {
  using value_t = property_value<register_map_key>;
};

struct stable_key {
  using value_t = property_value<stable_key>;
};

struct buffer_location_key {
  template<int K>
  using value_t = property_value<
    buffer_location_key, std::integral_constant<int, K>>;
};

struct awidth_key {
  template<int K>
  using value_t = property_value<
    awidth_key, std::integral_constant<int, K>>;
};

struct dwidth_key {
  template<int K>
  using value_t = property_value<
    dwidth_key, std::integral_constant<int, K>>;
};

enum class read_write_mode_enum {
  read_write,
  read,
  write
};

struct read_write_mode_key {
  template<read_write_mode_enum mode>
  using value_t = property_value<read_write_mode_key,
    std::integral_constant<read_write_mode_enum, mode>>;
};

struct latency_key {
  template<int K>
  using value_t = property_value<latency_key,
    std::integral_constant<int, K>>;
};

struct maxburst_key {
  template<int K>
  using value_t = property_value<
    maxburst_key, std::integral_constant<int, K>>;
};

struct wait_request_key {
  template<bool K>
  using value_t = property_value<wait_request_key,
    std::integral_constant<bool, K>>;
};

inline constexpr conduit_key::value_t
 conduit;
inline constexpr register_map_key::value_t
 register_map;
inline constexpr stable_key::value_t stable;
template<int K> inline constexpr buffer_location_key::value_t<K>
 buffer_location;
template<int K> inline constexpr awidth_key::value_t<K>
 awidth;
template<int K> inline constexpr dwidth_key::value_t<K>
 dwidth;
template<read_write_mode_enum mode>
inline constexpr read_write_mode_key::value_t<mode>
 read_write_mode;
inline constexpr read_write_mode_key::value_t<
  read_write_mode_enum::read>  read_write_mode_read;
inline constexpr read_write_mode_key::value_t<
  read_write_mode_enum::write>  read_write_mode_write;
inline constexpr read_write_mode_key::value_t<
  read_write_mode_enum::read_write>
    read_write_mode_readwrite;
template<int K> inline constexpr latency_key::value_t<K>
  latency;
template<int K> inline constexpr maxburst_key::value_t<K>
 maxburst;
template<int K> inline constexpr wait_request_key::value_t<K>
 wait_request;
inline constexpr wait_request_key::value_t<true>
 wait_request_requested;
inline constexpr wait_request_key::value_t<false>
 wait_request_not_requested;

template<> struct is_property_key<conduit_key> : std::true_type {};
template<> struct is_property_key<
  register_map_key> : std::true_type {};
template<> struct is_property_key<stable_key> : std::true_type {};
template<> struct is_property_key<buffer_location_key> : std::true_type {};
template<> struct is_property_key<awidth_key> : std::true_type {};
template<> struct is_property_key<dwidth_key> : std::true_type {};
template<> struct is_property_key<
  read_write_mode_key> : std::true_type {};
template<> struct is_property_key<
  latency_key> : std::true_type {};
template<> struct is_property_key<maxburst_key> : std::true_type {};
template<> struct is_property_key<
  wait_request_key> : std::true_type {};

template <typename T, typename PropertyListT>
struct is_property_key_of<conduit_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<register_map_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<stable_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<buffer_location_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<awidth_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<dwidth_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<read_write_mode_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<latency_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<maxburst_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<wait_request_key,
  annotated_ptr<T, PropertyListT>> : std::true_type {};
} // namespace experimental::oneapi::ext::sycl
```
--

[frame="topbot",options="header"]
|===
|Property |Description

a|
[source,c++]
----
conduit
----
a|
Directs the compiler to create a dedicated input port on the kernel for the
input.

a|
[source,c++]
----
register_map
----
a|
Directs the compiler to create a register to store the input as opposed to
creating a dedicated input port on the kernel.

a|
[source,c++]
----
stable
----
a|
Specifies that the input to the kernel will not change during the execution of
the kernel. The input can still change after all active kernel invocations have
finished.

If the input is changed while the kernel is executing, the behavior is
undefined.

a|
[source,c++]
----
buffer_location<id>
----
a|
Specifies a global memory identifier for the pointer interface.

a|
[source,c++]
----
awidth<width>
----
a|
Specifies the width of the memory-mapped address bus in bits. The default is
set to 64.

a|
[source,c++]
----
dwidth<width>
----
a|
Specifies the width of the memory-mapped data bus in bits. The default is set
to 64.

a|
[source,c++]
----
read_write_mode<mode>
----
a|
Specifies the port direction of the memory interface associated with the input
pointer. `mode` can be one of:

`read_write` - Interface can be used for read and write operations.

`read` - Interface can only be used for read operations.

`write` - Interface can only be used for write operations.

The default is set to `read_write`.

For convenience, the following are provided:

 - read_write_mode_read
 - read_write_mode_write
 - read_write_mode_readwrite

a|
[source,c++]
----
latency<value>
----
a|
Specifies the guaranteed latency in cycles, from when a read command exits
the kernel to when the external memory returns valid read data. The default
is set to 1.

A value of 0 specifies a variable latency and a positive value specifies a
fixed latency.

a|
[source,c++]
----
maxburst<value>
----
a|
Specifies the maximum number of data transfers that can be associated with a
read or write transaction. The default is set to 1.

a|
[source,c++]
----
wait_request<flag>
----
a|
Specifies whether the 'wait request' signal is generated or not. This signal is
asserted by the memory system when it is unable to respond to a read or write
request. The default is set to `false`.

For convenience, the following are provided:

 - wait_request_requested
 - wait_request_not_requested
|===
--

=== Usage Examples

The example below shows a simple kernel with two annotated pointer kernel
arguments 'arg_a' and 'arg_b'.

.Usage Example
```c++
using sycl::ext::oneapi::experimental;
{
  sycl::queue q{...};

  // Allocate memory
  auto ptr_a = ...
  auto ptr_b = ...

  // Add properties
  auto arg_a = annotated_ptr(
    ptr_a, properties{buffer_location<1>, awidth<32>, dwidth<32>});
  auto arg_b = annotated_ptr(
    ptr_b, properties{buffer_location<2>, awidth<64>, dwidth<128>});

  q.single_task([=] {
    ...
    arg_a[index] *= 2;
    arg_b[index] *= 4;
    ...
  }).wait();

  ...
}
```

== Issues

1. Should we add a new property argument to `latency` to separate specifying
fixed latency and variable latency.
Yes, in a future extension we can introduce a separate property.

2. How do I link the fpga_kernel_properties spec to this one, to specify that
certain fpga kernel properties should result in changes to kernel arguments.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date       |Author           |Changes
|1  |2022-04-13 |Abhishek Tiwari  |*Initial draft*
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
